<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:w="urn:schemas-microsoft-com:office:word" xmlns="http://www.w3.org/TR/REC-html40"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/></head><a href="http://www.jactc.com"><img src="http://www.jactc.com/images/logo.png" alt="慧知网" /></a>
<h1>linux实验6</h1>
原文地址：http://www.jactc.com/view/4a3e9121b035f50fc2f7aed9dd6b42a0.html
<hr />
<p>电 子 科 技 大 学</p>
<p>作</p>
<p>学生姓名：朱游娟</p>
<p>业</p>
<p>报</p>
<p>告</p>
<p>指导教师：李林</p>
<p>学 号：201322060604</p>
<p>学生 E-mail：942920728@qq.com（影墨薰殇） 一、作业名称</p>
<p>实现英文词频统计程序</p>
<p>二、作业要求</p>
<p>任务：给定多个目录，要求并发地统计这些目录下所有文件中，英文单词出 现的次数。 假设：目录下的文件只包含英文单词。 限制：采用多进程协作的方式。 词频统计结果需要写入指定的结果文件。用户可以通过查看这一结果文件， 了解这些目录下文件中的词频统计信息。</p>
<p>三、设计与实现</p>
<p>经过分析可知，本任务需要父进程与多个字进程一起协作完成。其中，子进 程是负责读取指定目录下的文件，然后对每个文件进行单词统计；父进程是负责 接收子进程的中间结果，对结果进行合并，并在合并完成后写入结果文件。在父 子进程通信的时候， 我们调用了程序库的进程通信接口，从而实现父子进程之间 消息的收发。 将整个实现过程分为 Map 和 Reduce 两个阶段。 1、Map 阶段： 主进程根据输入的木木数量创建多个进程，每个进程处理一个目录； 子进程获取到目录名后，遍历整个目录，对该目录下的每个文件执行单词统计， 并把得到的中间结果保存下来；</p>
<p>子进程在统计结束后，把中间结果发送给主进程。 2、Reduce 阶段： 进程接收子进程的中间结果，并对结果进行合并； 子进程在发送完中间结果后，父进程向其发送退出消息，子进程接收到后退 出； 父进程检查每个子进程是否都退出，如果每个子进程都已经退出，那么整个 工作完成，父进程将合并后的结果写入文件，父进程退出，否则，父进程等待所 有子进程完成工作。 关键代码如下： /*继承类CLMessage的类CLFatherInitMsg */ class CLFatherInitMsg : public CLMessage { public: /*无参构造函数，且不进行任何操作*/ CLFatherInitMsg() : CLMessage(FATHER_INIT_MESSAGE_ID) { } /*类成员变量，即为消息中的携带的目录名*/ public: string dirname; }; /*消息FatherInitMsg的序列化类CLFatherInitMsgSerializer 的定义*/ class CLFatherInitMsgSerializer : public CLMessageSerializer { public: /*序列化虚函数，在继承时需要给出实现*/ virtual char *Serialize(CLMessage *pMsg,unsigned int *pFullLength,unsigned int HeadLength) { CLFatherInitMsg *p = dynamic_cast&lt;CLFatherInitMsg *&gt;(pMsg); if(p == 0) { cout &lt;&lt; &quot;dynamic_cast error&quot; &lt;&lt;endl; return 0; } /*获取到此消息中包含的目录名的长度*/ unsigned int dir_len = p-&gt;dirname.size();</p>
<p>/*计算该消息的总长度*/ *pFullLength = HeadLength + sizeof(long) + sizeof(unsigned int) + dir_len; /*创建保存消息的缓存空间*/ char *pBuf = new char[*pFullLength]; long *pId = (long *)(pBuf + HeadLength); *pId = p-&gt;m_clMsgID; /*放入目录名的长度*/ unsigned int *len = (unsigned int *)(pBuf + HeadLength + sizeof(long)); *len = dir_len; /*放入目录名*/ char *dirname = (char *)(pBuf + HeadLength + sizeof(long) + sizeof(unsigned int)); memcpy(dirname,p-&gt;dirname.c_str(),dir_len); /*返回字符串*/ return pBuf; } }; /*消息FatherInitMsg的反序列化类CLFatherInitMsgDeserializer 的定义*/ class CLFatherInitMsgDeserializer : public CLMessageDeserializer { public: /*虚函数，需要在继承时给出实现*/ virtual CLMessage *Deserialize(char *pBuffer) { /*对接收到的消息ID进行验证，如果不是消息FatherInitMsg的ID，返回 0*/ long id = *((long *)pBuffer); if(id != FATHER_INIT_MESSAGE_ID) return 0; /*创建该消息*/ CLFatherInitMsg *p = new CLFatherInitMsg; /*获取到该字符串报文中包含的数据长度，即为目录名的长度*/ unsigned int t_len = *((unsigned int *)(pBuffer + sizeof(id))); char str[t_len + 1]; memset(str,0,sizeof(char) * (t_len + 1));</p>
<p>/*按照得到的数据长度获取数据，从而获取到目录名*/ const char *dirname = (char *)(pBuffer + sizeof(id) + sizeof(t_len)); memcpy(str,dirname,t_len); p-&gt;dirname = string(str); /*返回消息*/ return p; } }; /*该类负责父进程的消息处理工作*/ class CLFatherWordCountObserver : public CLMessageObserver { public: /*构造函数，对成员变量进行初始化*/ CLFatherWordCountObserver() { m_Child = NULL; } /*析构函数，等待所有子进程死亡，并释放相应内存空间*/ virtual ~CLFatherWordCountObserver() { for(int i = 0; i &lt; m_process_num; i++) if(m_Child[i] != NULL) m_Child[i]-&gt;WaitForDeath(); delete[] m_Child; } void PushDirname(char *dirname) { m_dirlist.push_back(dirname); } void Init( ) { m_process_num = m_dirlist.size(); m_Child = new CLExecutive *[m_process_num]; for(int i = 0; i &lt; m_process_num; i++) m_Child[i] = NULL;</p>
<p>m_quit_count = 0; m_dir_num = 0; } /*继承父类的函数，需要自己重新实现*/ virtual CLStatus Initialize(CLMessageLoopManager *pMessageLoop, void* pContext) { pMessageLoop-&gt;Register(CHILD_INIT_MESSAGE_ID, (CallBackForMessageLoop)(&amp;CLFatherWordCountObserver::On_Child_Init)); pMessageLoop-&gt;Register(CHILD_SEND_REQUEST_MESSAGE_ID, (CallBackForMessageLoop)(&amp;CLFatherWordCountObserver::On_Child_Send_Re quest)); pMessageLoop-&gt;Register(INTERMEDIATE_RESULT_MESSAGE_ID, (CallBackForMessageLoop)(&amp;CLFatherWordCountObserver::On_Intermediate_ Result)); pMessageLoop-&gt;Register(CHILD_WORK_FINISH_MESSAGE_ID, (CallBackForMessageLoop)(&amp;CLFatherWordCountObserver::On_Child_Work_Fi nish)); for(int i = 0;i &lt; m_process_num; i++) { stringstream t_index; t_index &lt;&lt; i+1; string runcmd = string(&quot;./test/a.out child_pipe&quot;) + t_index.str(); m_Child[i] = new CLProcess(new CLProcessFunctionForExec, true); if(!((m_Child[i]-&gt;Run((void *)(runcmd.c_str( )))).IsSuccess())) { cout &lt;&lt; &quot;Run error&quot; &lt;&lt; endl; m_Child[i] = NULL; } } return CLStatus(0, 0); } /*该函数负责处理子进程的ChildInitMsg*/ CLStatus On_Child_Init(CLMessage *pm) { CLChildInitMsg *p = dynamic_cast&lt;CLChildInitMsg*&gt;(pm);</p>
<p>if(p == 0) return CLStatus(0,0); string childname = p-&gt;childname; cout &lt;&lt; &quot;Father :: receive child &quot;&lt;&lt; childname &lt;&lt; &quot; init msg ok !!!!!!!!!!!!!!!&quot; &lt;&lt; endl &lt;&lt; endl; CLSharedExecutiveCommunicationByNamedPipe *pSender = new CLSharedExecutiveCommunicationByNamedPipe(childname.c_str()); pSender-&gt;RegisterSerializer(FATHER_INIT_MESSAGE_ID,new CLFatherInitMsgSerializer); pSender-&gt;RegisterSerializer(FATHER_ACK_MESSAGE_ID,new CLFatherAckMsgSerializer); pSender-&gt;RegisterSerializer(QUIT_MESSAGE_ID,new CLQuitMsgSerializer); /*将消息通信类注册到执行名字服务类中*/ CLExecutiveNameServer::GetInstance()-&gt;Register(childname.c_str(),pSen der); CLFatherInitMsg *pFatherInitMsg = new CLFatherInitMsg; pFatherInitMsg-&gt;dirname = m_dirlist[m_dir_num ++]; cout &lt;&lt; &quot;Father :: send init msg to &quot; &lt;&lt; childname &lt;&lt; &quot; !!!!!!!!!!!!!!!!&quot; &lt;&lt; endl &lt;&lt; endl; CLExecutiveNameServer::PostExecutiveMessage(childname.c_str(),pFather InitMsg); return CLStatus(0,0); } CLStatus On_Child_Send_Request(CLMessage *pm) { CLChildSendRequestMsg *p = dynamic_cast&lt;CLChildSendRequestMsg *&gt;(pm); if(p == 0) return CLStatus(0,0); string childname = p-&gt;childname; cout &lt;&lt; &quot;Father :: receive &quot; &lt;&lt; childname.c_str() &lt;&lt; &quot; send request ok !!!!!!!!!!!!!!!!!&quot; &lt;&lt; endl &lt;&lt; endl; CLFatherAckMsg *pFatherAckMsg = new CLFatherAckMsg; cout &lt;&lt; &quot;Father :: send ack msg to &quot; &lt;&lt; childname &lt;&lt;</p>
<p>&quot; !!!!!!!!!!!!!!!!!&quot; &lt;&lt; endl &lt;&lt; endl; CLExecutiveNameServer::PostExecutiveMessage(childname.c_str(),pFa therAckMsg); return CLStatus(0,0); } CLStatus On_Intermediate_Result(CLMessage *pm) { CLIntermediateResultMsg *p = dynamic_cast&lt;CLIntermediateResultMsg*&gt;(pm); if(p == 0) return CLStatus(0, 0); string word = p-&gt;data.word; unsigned int count = p-&gt;data.count; iter = word_table.find(word); if(iter == word_table.end()) word_table.insert(pair&lt;string,unsigned int&gt;(word,count)); else iter-&gt;second += count; return CLStatus(0,0); } CLStatus On_Child_Work_Finish(CLMessage *pm) { CLChildWorkFinishMsg *p = dynamic_cast&lt;CLChildWorkFinishMsg *&gt;(pm); if(p == 0) return CLStatus(0,0); string childname = p-&gt;childname; cout &lt;&lt; &quot;Father :: receive child &quot;&lt;&lt; childname &lt;&lt;&quot; work finish msg ok !!!!!!!!!!!!!!!&quot; &lt;&lt; endl &lt;&lt; endl; CLQuitMsg *pQuitMsg = new CLQuitMsg;</p>
<p>CLExecutiveNameServer::PostExecutiveMessage(childname.c_str(),pQu itMsg); CLExecutiveNameServer::GetInstance()-&gt;ReleaseCommunicationPtr(childna</p>
<p>me.c_str()); if((++m_quit_count) &lt; m_process_num) return CLStatus(0,0); fstream outfile; outfile.open(&quot;./result&quot;,fstream::out); for(iter = word_table.begin(); iter != word_table.end(); iter++) { outfile &lt;&lt; iter-&gt;first; outfile &lt;&lt; &quot;\t&quot;; outfile &lt;&lt; iter-&gt;second; outfile &lt;&lt; &quot;\n&quot;; } outfile.close(); cout &lt;&lt; &quot;Father :: work done,quit !!!!!!!!!!!!!!!!!!!&quot; &lt;&lt; endl &lt;&lt; endl; return CLStatus(QUIT_MESSAGE_LOOP,0); } /*私有类成员变量定义*/ private: /*用于创建多个子进程的执行类*/ CLExecutive **m_Child; vector&lt;string&gt; m_dirlist; /*父进程用来存储单词统计结果*/ map&lt;string,unsigned int&gt; word_table; map&lt;string,unsigned int&gt;::iterator iter; unsigned short m_process_num; unsigned short m_quit_count; unsigned short m_dir_num; }; /*负责子进程的消息处理工作*/ class CLChildWordCountObserver : public CLMessageObserver { public: /*构造函数*/</p>
<p>CLChildWordCountObserver(string t_name = &quot;&quot;):childname(t_name) { } /*析构函数*/ virtual ~CLChildWordCountObserver() { } /*负责初始化工作*/ virtual CLStatus Initialize(CLMessageLoopManager *pMessageLoop,void* pContext) { /*注册消息ID的回调函数*/ pMessageLoop-&gt;Register(FATHER_INIT_MESSAGE_ID,(CallBackForMessage Loop)(&amp;CLChildWordCountObserver::On_ReadDir)); pMessageLoop-&gt;Register(FATHER_ACK_MESSAGE_ID,(CallBackForMessageL oop)(&amp;CLChildWordCountObserver::On_Father_Ack)); pMessageLoop-&gt;Register(QUIT_MESSAGE_ID,(CallBackForMessageLoop)(&amp; CLChildWordCountObserver::On_Quit)); /*把将要发送给父进程的消息注册*/ CLSharedExecutiveCommunicationByNamedPipe *pSender = new CLSharedExecutiveCommunicationByNamedPipe(&quot;father_pipe&quot;); pSender-&gt;RegisterSerializer(CHILD_INIT_MESSAGE_ID, new CLChildInitMsgSerializer); pSender-&gt;RegisterSerializer(CHILD_SEND_REQUEST_MESSAGE_ID, new CLChildSendRequestMsgSerializer); pSender-&gt;RegisterSerializer(INTERMEDIATE_RESULT_MESSAGE_ID, new CLIntermediateResultMsgSerializer); pSender-&gt;RegisterSerializer(CHILD_WORK_FINISH_MESSAGE_ID, new CLChildWorkFinishMsgSerializer); pSender-&gt;RegisterSerializer(QUIT_MESSAGE_ID, new CLQuitMsgSerializer); CLExecutiveNameServer::GetInstance()-&gt;Register(&quot;father_pipe&quot;, pSender); /*子进程向父进程发送ChildInitMsg，表示子进程已经准备开始工作*/ CLChildInitMsg *pChildInitMsg = new CLChildInitMsg; pChildInitMsg-&gt;childname = childname; cout &lt;&lt; &quot;Child &quot; &lt;&lt; childname &lt;&lt; &quot;:: send init msg !!!!!!!!!!!!!!!!! &quot; &lt;&lt; endl &lt;&lt; endl; CLExecutiveNameServer::PostExecutiveMessage(&quot;father_pipe&quot;,pChildI nitMsg);</p>
<p>return CLStatus(0,0); } CLStatus On_ReadDir(CLMessage *pm) { CLFatherInitMsg *p = dynamic_cast&lt;CLFatherInitMsg *&gt;(pm); if(p == 0) return CLStatus(0,0); cout &lt;&lt; &quot;Child &quot;&lt;&lt; childname &lt;&lt; &quot;:: receive father init ok !!!!!!!!!!!!!!&quot; &lt;&lt; endl &lt;&lt; endl; string dirname = p-&gt;dirname; WordCount wc(dirname); wc.DirWordCount(word_table); CLChildSendRequestMsg *pChildSendRequestMsg = new CLChildSendRequestMsg; pChildSendRequestMsg-&gt;childname = childname; cout &lt;&lt; &quot;Child &quot; &lt;&lt; childname &lt;&lt; &quot;:: send requtst meg !!!!!!!!!!!!!!!&quot; &lt;&lt; endl &lt;&lt; endl; CLExecutiveNameServer::PostExecutiveMessage(&quot;father_pipe&quot;,pChildS endRequestMsg); return CLStatus(0,0); } CLStatus On_Father_Ack(CLMessage *pm) { CLFatherAckMsg *p = dynamic_cast&lt;CLFatherAckMsg *&gt;(pm); if(p == 0) return CLStatus(0,0); cout &lt;&lt; &quot;Child &quot; &lt;&lt; childname &lt;&lt; &quot;:: receive father ack msg !!!!!!!!!!!!!!!!&quot; &lt;&lt; endl &lt;&lt; endl; for(iter = word_table.begin(); iter != word_table.end(); iter++) { CLIntermediateResultMsg *pIntermediateResultMsg = new CLIntermediateResultMsg; pIntermediateResultMsg-&gt;data.word = iter-&gt;first;</p>
<p>pIntermediateResultMsg-&gt;data.count = iter-&gt;second; CLExecutiveNameServer::PostExecutiveMessage(&quot;father_pipe&quot;, pIntermediateResultMsg); } CLChildWorkFinishMsg *pChildWorkFinishMsg = new CLChildWorkFinishMsg; pChildWorkFinishMsg-&gt;childname = childname; cout &lt;&lt; &quot;Child &quot; &lt;&lt; childname &lt;&lt;&quot;:: send work finish msg !!!!!!!!!!!!!!!&quot; &lt;&lt; endl &lt;&lt; endl; CLExecutiveNameServer::PostExecutiveMessage(&quot;father_pipe&quot;,pChildW orkFinishMsg); return CLStatus(0,0); } CLStatus On_Quit(CLMessage *pm) { CLQuitMsg *p = dynamic_cast&lt;CLQuitMsg*&gt;(pm); if(p == 0) return CLStatus(0,0); cout &lt;&lt; &quot;Child :: receive quit msg !!!!!!!!!!!!!!!!&quot; &lt;&lt; endl &lt;&lt; endl; /*析构掉与父进程的消息通信类*/ CLExecutiveNameServer::GetInstance()-&gt;ReleaseCommunicationPtr(&quot;fa ther_pipe&quot;); /*退出进程*/ return CLStatus(QUIT_MESSAGE_LOOP,0); } /*私有类成员变量定义*/ private: string childname; map&lt;string,unsigned int&gt; word_table; map&lt;string,unsigned int&gt;::iterator iter; };</p>
<p>四、测试</p>
<p>/*下面为子进程的main函数，描述了子进程的执行过程*/ int main(int argc,char *argv[]) { /*对参数进行判断*/</p>
<p>if(argc != 2) { cout &lt;&lt; &quot;usage:./a.out childname &quot; &lt;&lt; endl; exit(-1); } try { if(!CLLibExecutiveInitializer::Initialize().IsSuccess()) { cout &lt;&lt; &quot;Initialize error&quot; &lt;&lt; endl; return 0; } CLNonThreadForMsgLoop child_nonthread(new CLChildWordCountObserver(argv[1]),argv[1],EXECUTIVE_BETWEEN_PROCESS_U SE_PIPE_QUEUE); /*将3种消息ID的反序列类注册到消息循环过程中*/ child_nonthread.RegisterDeserializer(FATHER_INIT_MESSAGE_ID, new CLFatherInitMsgDeserializer); child_nonthread.RegisterDeserializer(FATHER_ACK_MESSAGE_ID, new CLFatherAckMsgDeserializer); child_nonthread.RegisterDeserializer(QUIT_MESSAGE_ID, new CLQuitMsgDeserializer); /*开始消息循环*/ child_nonthread.Run(0); throw CLStatus(0, 0); } catch(CLStatus&amp; s) { if(!CLLibExecutiveInitializer::Destroy().IsSuccess()) cout &lt;&lt; &quot;Destroy error&quot; &lt;&lt; endl; return 0; } } /*主进程的 main 函数，描述了主进程的执行过程*/ int main(int argc,char **argv) { if(argc &lt; 2) { cout &lt;&lt; &quot;usage:./a.out [dirname1] [dirname2] ... &quot; &lt;&lt;endl; exit(-1);</p>
<p>} try { if(!CLLibExecutiveInitializer::Initialize().IsSuccess()) { cout &lt;&lt; &quot;Initialize error&quot; &lt;&lt; endl; return 0; } /*创建FatherWordCountObserver类，并以此将输入的目录名放入该类 中，执行该类的初始化工作*/ CLFatherWordCountObserver *pFatherWordCountObserver = new CLFatherWordCountObserver; for(int i = 1;i &lt; argc; i++) pFatherWordCountObserver-&gt;PushDirname(argv[i]); pFatherWordCountObserver-&gt;Init(); /*创建主进程的消息循环过程*/ CLNonThreadForMsgLoop father_nonthread(pFatherWordCountObserver, &quot;father_pipe&quot;, EXECUTIVE_BETWEEN_PROCESS_USE_PIPE_QUEUE); /*调用RegisterDeserializer函数将4种消息ID的反序列化类注册到消 息循环中*/ father_nonthread.RegisterDeserializer(CHILD_INIT_MESSAGE_ID, new CLChildInitMsgDeserializer); father_nonthread.RegisterDeserializer(CHILD_SEND_REQUEST_MESSAGE_ID, new CLChildSendRequestMsgDeserializer); father_nonthread.RegisterDeserializer(INTERMEDIATE_RESULT_MESSAGE _ID, new CLIntermediateResultMsgDeserializer); father_nonthread.RegisterDeserializer(CHILD_WORK_FINISH_MESSAGE_I D, new CLChildWorkFinishMsgDeserializer); /*开始消息循环*/ father_nonthread.Run(0); throw CLStatus(0, 0); } catch(CLStatus&amp; s) { if(!CLLibExecutiveInitializer::Destroy().IsSuccess()) cout &lt;&lt; &quot;Destroy error&quot; &lt;&lt; endl; return 0; }</p>
<p>}</p>
<p>五、对本课程或本作业的建议和意见</p>
<p>通过本次作业，我对 Linux 系统下进行多进程编程有了更深入的了解，对多 进程协作完成相应功能的有关机制有了初步的认识， 这将对我以后的编程生涯产 生积极的作用。</p>
<p>六、附录</p>
<p>见文件夹“homework6” ，其中，文件夹“include”包含需要使用到的执行 库中的头文件， 文件夹 “src” 包含需要使用到执行库中的源程序， 文件 “Makefile” 为编译需要使用到的项目管理文件，文件“test.cpp”为父进程实现文件，文件 “MessageHead.h”为父进程相应类定义头文件，文件夹“test”包含子进程相 应类定义头文件及实现文件，以及程序运行所需要用到的目录文件。</p>
<p></p><hr />
<ul>
    </ul>
</html>